<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EnigmaIOT: readme.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo text inside.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EnigmaIOT
   &#160;<span id="projectnumber">0.9.0</span>
   </div>
   <div id="projectbrief">Secure sensor and gateway platform based on ESP8266 and ESP32</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">readme.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="readme_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# EnigmaIoT</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;&lt;img src=&quot;https://github.com/gmag11/EnigmaIOT/raw/master/logo/logo%20text%20under.svg?sanitize=true&quot; alt=&quot;EnigmaIoT Logo&quot; width=&quot;50%&quot;/&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;## Introduction</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;**EnigmaIoT** is an open source solution for wireless multi sensor systems. It has two main components, multiple **nodes** and one **gateway**.</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;A number of nodes with one or more sensors each one communicate in a **secure** way to a central gateway in a star network using EnigmaIoT protocol.</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;This protocol has been designed with security on mind. All sensor data is encrypted with a random key that changes periodically. Key is unique for each node and dynamically negotiated, so user do not have to enter any key. Indeed, all encryption and key agreement is transparent to user.</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;I designed this because I was searching for a way to have a relatively high number of nodes at home. I thought about using WiFi but it would overload my home router. So I looked for an alternative. I evaluated  LoRa or cheap nRF24 modules but I wanted the simplest solution in terms of hardware.</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;ESP8266 microcontroller implements a protocol known as ESP-NOW. It is a point to point protocol, based on vendor specific [WiFi management action frames](https://mrncciew.com/2014/09/29/cwap-802-11-mgmt-frame-types/), that works in a connectionless way and every packet is a few milliseconds long. Because of this it eases to have a battery powered node so that it enables designing totally wireless sensors.</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;But use of encryption on ESP-NOW limits the number of nodes to only 6 nodes. So I thought that I could implement encryption on payload but I found many problems I should solve to grade this as &quot;secure enough&quot;.</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;Find library documentation on https://gmag11.github.io/EnigmaIOT</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;## Project requirements</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;During this project conception I decided that it should fulfil this list of requirements.</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;- Use the simplest hardware, based on ESP8266.</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;- Secure by design. Make use of a secure channel for data transmission.</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;- Automatic dynamic key agreement.</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;- Do not require connection to the Internet.</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;- Do not overload my home WiFi infrastructure. Only Gateway may be connected to LAN.</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;- Able to use deep sleep to run on batteries.</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;- Enough wireless range for a house.</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;- Support for a high number of nodes.</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;## Features</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;- [x] Encrypted communication using [**ChaCha20/Poly1305**](https://tools.ietf.org/html/rfc7539)</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;- [x] Dynamic key, shared between one node and gateway. Keys are independent for each node</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;- [x] Shared keys are expired after a certain (configurable) time.</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;- [x] Number of nodes is only limited by memory on gateway (60 bytes per node)</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;- [x] Key is never on air so it is cannot be captured</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;- [x] Key expiration and renewal is managed transparently</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;- [x] Avoid repeatability attack having a new random initialization vector on every message. This is mandatory for ChaCha20/Poly1305 in order to keep cipher secure</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;- [x] Automatic and transparent node attachment</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;- [x] Avoid rogue node, rogue gateway and man-in-the-middle attack</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;Notice that network key used to implement this feature is stored on flash. ESP8266 do not allow flash encryption so network key may be recovered reading flash.</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;- [x] Pluggable physical layer communication. Right now only ESP-NOW protocol is developed but you can easily add more communication alternatives</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;- [x] When using ESP-NOW only esp8266 is needed. No more electronics apart from sensor</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;- [x] Data message counter to detect lost or repeated messages</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;- [x] Designed as two libraries (one for gateway, one for node) for easier use</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;- [x] Crypto algorithm could be changed with low effort</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;- [x] Node and Gateway do store shared keys only on RAM. They are lost on power cycle. This protects system against flash reading attack. All nodes attach automatically with a new shared key after gateway is switched on</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;- [x] Downlink available. If deep sleep is used on sensor nodes, it is queued and sent just after node send a data message</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;- [x] Optional sleep mode management. In this case key has to be stored temporally. Normally RTC memory is the recommended place, and it is the one currently implemented</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;- [x] Initial configuration over WiFi portal on each device</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;- [x] Node configuration while in service using control downlink commands</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;- [ ] OTA over WiFi</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;- [x] OTA over MQTT/ESP-NOW</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;- [x] Sensor identification by using a flashing LED. This is useful when you have a bunch of nodes together :D</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;- [ ] Broadcast messages that go to all nodes. Under study</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;## Design</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;### System Design</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;System functions are divided in three layers: application, link and physical layer.</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;![Software Layers](https://github.com/gmag11/EnigmaIOT/raw/master/img/system_layers.png)</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;- **Application layer** is not controlled by EnigmaIoT protocol but main program. User may choose whatever data format or final destination of payload. A good option is to use CayenneLPP format but any other format or even raw data may be used. The only limit is the maximum packet length that, for ESP-NOW is around 200 bytes.</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;- **Link layer** is the one that add privacy and security. It manages connection between nodes and gateway in a transparent way. It does key agreement and node registration and checks the correctness of data messages. In case of any error it automatically start a new registration process. On this layer, data packets are encrypted using calculated symmetric key.</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;- **Physical layer** currently uses connectionless ESP-NOW. But a hardware abstraction layer has been designed so it is possible to develop interfaces for any other layer 1 technology like LoRa or nRF24F01 radios.</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;### EnigmaIoT protocol</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;The named **EnigmaIoT protocol** is designed to use encrypted communication without the need to hardcode the key. It uses [Elliptic Curves Diffie Hellman](https://en.wikipedia.org/wiki/Elliptic-curve_Diffie–Hellman) algorithm to calculate a shared key.</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;The process starts with node announcing itself with a Client Hello message. It tells the gateway its intention to establish a new shared key. It sends public key to be used on gateway to calculate the shared key.</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;Gateway answers with Server Hello message that includes its public key for shared key calculation on node.</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;Once shared key is calculated, node send an encrypted message as Key Exchange Finished message. Poly1305 encryption tag is used to check message integrity.</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;If gateway validates tag correctly it answers with a Cipher Finished message.</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;This process is protected with a 32 byte shared **network key**, used for **authentication**. As in the first two messages shared key is not known yet, Client Hello and Server Hello messages are encrypted whit this network key. If network key is not the same on gateway and node this will lead to decryption errors and messages will be ignored.</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;In case of any error on node key negotiation gateway sends an Invalidate Key to reset to original status and forgets any calculated shared key for this node.</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;When key is marked as valid node may start sending sensor data.</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;Optionally, gateway can send data to node. As node may be sleeping between communications, downlink messages has to be sent just after uplink data. So, one downlink message is queued until node communicates. Node waits some milliseconds before sleep for downlink data.</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;If a new downlink message arrives, old scheduled data for that node, if any, is overwritten.</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;In case of nodes that do not sleep (like a mains powered relay), gateway can send downlink data in any moment. Sleepy node is signaled during node registration on a bit in Key Exchange Finished message. It is set to 1 to signal that node will sleep just after sending data.</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;Key is forced to change every period. Gateway decides the moment to invalidate each node key. If so, it sends an invalidate key as downlink, after next data message communication. This key validity period is configurable on [EnigmaIoTconfig.h](https://github.com/gmag11/EnigmaIOT/blob/master/src/lib/EnigmaIoTconfig.h) file.</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;After that node may start new key agreement sending a new Client Hello message.</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;All nodes and gateway are identified by its MAC address. No name is assigned so no configuration is needed on node. Function assignment has to be done at a higher level.</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;## State diagram for nodes and Gateway</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;&lt;img src=&quot;https://github.com/gmag11/EnigmaIOT/raw/master/img/StateDiagram-Sensor.svg?sanitize=true&quot; alt=&quot;Sensor State Diagram&quot; width=&quot;800&quot;/&gt;</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;&lt;img src=&quot;https://github.com/gmag11/EnigmaIOT/raw/master/img/StateDiagram-Gateway.svg?sanitize=true&quot; alt=&quot;Gateway State Diagram&quot; width=&quot;800&quot;/&gt;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;## Message format specification</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;### Client Hello message</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;![Client Hello message format](https://github.com/gmag11/EnigmaIOT/raw/master/img/ClientHello.png)</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;Client hello is sent by node to start registration procedure. It includes the public key to be used on Elliptic Curve Diffie Hellman (EDCH) algorithm to calculate the key. Initialization vector (IV) is used for encryption. There is a random 4 byte field reserved for future use.</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;This message is sent encrypted with network key.</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;### Server Hello message</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;![Server Hello message format](https://github.com/gmag11/EnigmaIOT/raw/master/img/ServerHello.png)</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;After receiving and checking Client Hello message, gateway responds with a Server Hello message. It carries gateway&#39;s public key to let node calculate key using ECDH. There is a random 4 byte field reserved for future use. Gateway assigns node a NodeID. It is signaled as a 2 byte field.</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;Server Hello message is sent encrypted with network key.</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;### Sensor Data message</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;![Node payload message format](https://github.com/gmag11/EnigmaIOT/raw/master/img/SensorData.png)</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;Sensor data is always encrypted using shared key and IV. Apart from payload this message includes node ID and a counter used by gateway to check lost or repeated messages from that node.</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;Total message length (without tag) is included on a 2 byte field.</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;### Unencrypted Sensor Data message</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;![Node unencrypted payload message format](https://github.com/gmag11/EnigmaIOT/raw/master/img/UnencryptedSensorData.png)</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;In case that extreme performance is needed there is the possibility to send unencrypted data so processor spends a few milliseconds less. It is not recommended to do so unless you want to investigate crypto software performance. Use at your own data risk :D</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;This message also includes node ID and a counter used by gateway to check lost or repeated messages from that node.</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;### Node control message (downlink)</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;![Node control message format](https://github.com/gmag11/EnigmaIOT/raw/master/img/SensorCommand-Downlink.png)</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;Gateway can send commands to an individual node in a similar way as sensor data is sent by nodes. For nodes that can be slept between consecutive data messages this commands are queued and sent just after a data message is received.</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;Only last message is queued. In case Gateway tries to send a new message, old one gets deleted and overridden by the new one.</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;### Control message</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;##### Downlink Control Message</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;![DL Control Command message format](https://github.com/gmag11/EnigmaIOT/raw/master/img/ControlComand-Downlink.png)</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;##### Uplink Control Message</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;![UL Control Command message format](https://github.com/gmag11/EnigmaIOT/raw/master/img/ControlComand-Uplink.png)</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;Gateway  and node can exchange internal control commands. These are used to set internal protocol parameters like sleep time. This type of messages are processed like normal downlink messages, but are not passed to higher level (user code) in Node.</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;Some control messages, like OTA update messages, require that they are processed immediately. Hence, it is required that node is not in deep sleep mode. This can be controlled, for instance, using another control command to set sleep time to 0.</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;### Invalidate Key message</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;![Invalidate Key message format](https://github.com/gmag11/EnigmaIOT/raw/master/img/InvalidateKey.png)</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;After every data message from nodes, gateway evaluates key integrity and validity. In case of any error decoding the packet gateways ignores data and reply with this message indicating the reason that caused error. Node must start a new registration procedure in order to send data again. After this new registration node resends the last data message.</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;A gateway defines a key validity period after that a node key is marked as expired. In a message is received after that is processed normally but an Invalidate Key message indicating key expiration as reason. Node then starts a registration procedure but does not retry communication.</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;Invalidate Key message is always sent unencrypted.</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;## Protocol procedures</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;### Normal node registration and sensor data exchange</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;&lt;img src=&quot;https://github.com/gmag11/EnigmaIOT/raw/master/img/NodeRegistration.svg?sanitize=true&quot; alt=&quot;Normal node registration message sequence&quot; width=&quot;400&quot;/&gt;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;### Incomplete Registration</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;&lt;img src=&quot;https://github.com/gmag11/EnigmaIOT/raw/master/img/RegistrationIncomplete.svg?sanitize=true&quot; alt=&quot;Incomplete Registration message sequence&quot; width=&quot;400&quot;/&gt;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;### Node Not Registered</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;&lt;img src=&quot;https://github.com/gmag11/EnigmaIOT/raw/master/img/NodeNotRegistered.svg?sanitize=true&quot; alt=&quot;Node Not Registered message sequence&quot; width=&quot;400&quot;/&gt;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;### Key Expiration</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;&lt;img src=&quot;https://github.com/gmag11/EnigmaIOT/raw/master/img/KeyExpiration.svg?sanitize=true&quot; alt=&quot;KeyExpiration message sequence&quot; width=&quot;400&quot;/&gt;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;### Node Registration Collision</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;&lt;img src=&quot;https://github.com/gmag11/EnigmaIOT/raw/master/img/NodeRegistrationCollision.svg?sanitize=true&quot; alt=&quot;Node Registration Collision message sequence&quot; width=&quot;600&quot;/&gt;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;### Wrong Data Counter</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;&lt;img src=&quot;https://github.com/gmag11/EnigmaIOT/raw/master/img/WrongCounter.svg?sanitize=true&quot; alt=&quot;Wrong Counter message sequence&quot; width=&quot;400&quot;/&gt;</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;## Hardware description</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;### Node</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;A node is a ESP8266 board with a number of sensors. A node may sleep between sensor readings, status is stored so that it may send data without reconnection.</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;Any ESP8266 board with at least 1 MB of flash may be used.</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;There are several implementations in [examples](https://github.com/gmag11/EnigmaIOT/tree/master/examples):</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;[EnigmaIOT Node](https://github.com/gmag11/EnigmaIOT/tree/master/examples/enigmaiot_node): Basic node with deep sleep function. Sensor data is mocked up in example and sent using CayenneLPP encoding, you only need to replace it with your sensor reading code. Expected duration with 2 AA type batteries is more than one year, but a low power booster/regulator should be used in a custom ESP8266 board.</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;[Enigmaiot Node MsgPack](https://github.com/gmag11/EnigmaIOT/tree/master/examples/enigmaiot_node_msgpack): It has same functionality as the example above but uses JSON and MessagePack as Payload encoding.</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;[EnigmaIOT Node NonSleepy](https://github.com/gmag11/EnigmaIOT/tree/master/examples/enigmaiot_node_nonsleepy): Same functionality as previous examples but this does not sleep. This may be useful for sensors or actuators which are connected to mains, like light switches or smart plugs.</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;[EnigmaIOT LED Flasher](https://github.com/gmag11/EnigmaIOT/tree/master/examples/enigmaiot_led_flasher): On non sleepy nodes a common clock may be synchronized with gateway. This is an example of this. All nodes that include this firmware will flash their built in LED synchronously after successful registration. </div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;### Gateway</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;A gateway concentrates communication from all nodes, manages their registrations status, negotiate session key with them and outputs their messages to an output protocol.</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;[EnigmaIOT MQTT Gateway](https://github.com/gmag11/EnigmaIOT/tree/master/examples/EnigmaIOTGatewayMQTT) is the implementation for a MQTT gateway.</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;Since version 0.7.0 Gateway is a ESP32 or ESP8266 board with 4 MB of flash memory or more. ESP8266 gateways cannot use MQTT TLS encryption due to memory limitations.</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;Thanks to modular design, other output modules may be easily developed by implementing `GwOutput_generic.h`. Examples of this may be LoRaWAN output gateway, COAP gateway or any other network protocol that is needed. Even an offline SD data logger could be done.</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;I&#39;ve included a [Gateway with dummy output module](https://github.com/gmag11/EnigmaIOT/tree/master/examples/EnigmaIOTGatewayDummy) to show simple OutputGw module development.</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;## Data format</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;Although it is not mandatory at all, use of [CayenneLPP format](https://mydevices.com/cayenne/docs/lora/#lora-cayenne-low-power-payload) is recommended for sensor data compactness.</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;You may use [CayenneLPP library](https://github.com/ElectronicCats/CayenneLPP) for encoding on node and decoding on Gateway.</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;Example gateway code expands data message to JSON data, to be used easily as payload on a MQTT publish message to a broker. For JSON generation [ArduinoJSON](https://arduinojson.org) library is required.</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;In any case you can use your own format or even raw unencoded data. Take care of maximum message length that communications layer uses. For ESP-NOW, maximum payload length it is 217 bytes.</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;Since version 0.9 payload encoding is signalled on user data messages (both uplink and downlink) so new formats are possible. Currently  [CayenneLPP](https://mydevices.com/cayenne/docs/lora/#lora-cayenne-low-power-payload) and [MessagePack](https://msgpack.org) formats, in addition to RAW data, are possible. Check examples for usage instruction.</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;This change may produce incompatibilities with older versions so make sure you update your gateway and all your nodes to latest library version.</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;## ESP-NOW channel selection</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;Gateway has always its WiFi interface working as an AP. Its name correspond to configured Network Name.</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;During first start, after connecting supply, node tries to search for a WiFi AP with that name. Whet it is found, node will use its MAC address and channel as destination for ESP-NOW messages. It also gets RSSI (signal level) and reports it to gateway.</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;This information is stored in flash so node will use it to communicate in all following messages.</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;In the case that gateway has changed its channel (for instance due to a reconfiguration) node will not be able to communicate again.</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;If several transmission errors are detected by node, it starts searching for gateway again. When found it keeps sending messages normally.</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;So, node will always follow the channel that gateway is working in.</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;## Output data from gateway</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;### Uplink messages</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;A user may program their own output format modifying gateway example program. For my use case gateway outputs MQTT messages in this format:</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;```</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;&lt;configurable prefix&gt;/&lt;node address&gt;/data &lt;json data&gt;</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;```</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;A prefix is configured on gateway to allow several sensor networks to coexist in the same subnet. After that address and data are sent.</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;After every received message, gateway detects if any packet has been lost before and reports it using MQTT message using this format:</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;```</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;&lt;configurable prefix&gt;/&lt;node address&gt;/status {&quot;per&quot;:&lt;packet error rate&gt;,&quot;lostmessages&quot;:&lt;Number of lost messages&gt;,&quot;totalmessages&quot;:&lt;Total number of messages&gt;,&quot;packetshour&quot;:&lt;Packet rate&gt;}</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;```</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;### Downlink messages</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;EnigmaIoT allows sending messages from gateway to nodes. In my implementation I use MQTT to trigger downlink messages too.</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;To make it simpler, downlink messages use the same structure than uplink.</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;```</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;&lt;network name&gt;/&lt;node address&gt;/&lt;get|set&gt;/data &lt;command data&gt;</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;```</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;Node address means destination node address. Configurable prefix is the same used for uplink communication.</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;Commands may be given in JSON format. In that case they are  sent to node in MessagePack format. That makes that mode gets the complete JSON object. This implies that no change is needed on Gateway to add new node types. Gateway is transparent to user data.</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;This is an esample of MQTT message that triggers a downlink packet.</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;```</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;enigmaiot/12:34:56:78:90:12/set/data {&quot;light1&quot;: 1, &quot;light2&quot;: 0}</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;```</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;After sending that command node will receive a &#39;set&#39; command with data `{&quot;light1&quot;: 1, &quot;light2&quot;: 0}`.</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;Commands can be sent in any other format different that JSON, even binary. In that case they are sent without conversion to node.</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;### Control messages</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;Control messages are intended to set node specific settings, like sleep time, channel, trigger OTA update, etc. They are not passed to the main node sketch but gateway treat them as normal downlink messages.</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;Normally control commands trigger a response as an uplink message.</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;This is the list of currently implemented control commands:</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;- Get node protocol version</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;- Get sleep duration time</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;- Set sleep duration time</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;- OTA Update</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;- Identify</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;- Node configuration reset</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;- Request measure RSSI</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;&lt;table&gt;</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;  &lt;tr&gt;</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;    &lt;th colspan=&quot;2&quot;&gt;Command&lt;/th&gt;</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    &lt;th&gt;Response&lt;/th&gt;</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;  &lt;/tr&gt;</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;  &lt;tr&gt;</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;    &lt;td&gt;Get version&lt;/td&gt;</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;    &lt;td&gt;&lt;code&gt;&amp;lt;configurable prefix&amp;gt;/&amp;lt;node address&amp;gt;/get/version&lt;/code&gt;&lt;/td&gt;</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    &lt;td&gt;&lt;code&gt;&amp;lt;configurable prefix&amp;gt;/&amp;lt;node address&amp;gt;/result/version {&quot;version&quot;:&quot;&amp;lt;version&amp;gt;&quot;}&lt;/code&gt;&lt;/td&gt;</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;  &lt;/tr&gt;</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;  &lt;tr&gt;</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;    &lt;td&gt;Get sleep duration&lt;/td&gt;</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;    &lt;td&gt;&lt;code&gt;&amp;lt;configurable prefix&amp;gt;/&amp;lt;node address&amp;gt;/get/sleeptime&lt;/code&gt;&lt;/td&gt;</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    &lt;td&gt;&lt;code&gt;&amp;lt;configurable prefix&amp;gt;/&amp;lt;node address&amp;gt;/result/sleeptime {&quot;sleeptime&quot;:&quot;&amp;lt;sleep_time&amp;gt;&quot;}&quot;&lt;/code&gt;&lt;/td&gt;</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;  &lt;/tr&gt;</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;  &lt;tr&gt;</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;    &lt;td&gt;Set sleep duration&lt;/td&gt;</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;    &lt;td&gt;&lt;code&gt;&amp;lt;configurable prefix&amp;gt;/&amp;lt;node address&amp;gt;/set/sleeptime &amp;lt;sleep_time&amp;gt;&lt;/code&gt;&lt;/td&gt;</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    &lt;td&gt;&lt;code&gt;&amp;lt;configurable prefix&amp;gt;/&amp;lt;node address&amp;gt;/result/sleeptime {&quot;sleeptime&quot;:&quot;&amp;lt;sleep_time&amp;gt;&quot;}&lt;/code&gt;&lt;/td&gt;</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;  &lt;/tr&gt;</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;  &lt;tr&gt;</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;    &lt;td&gt;OTA message&lt;/td&gt;</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;    &lt;td&gt;&lt;code&gt;&amp;lt;configurable prefix&amp;gt;/&amp;lt;node address&amp;gt;/set/ota &amp;lt;ota message&amp;gt;&lt;/code&gt;&lt;/td&gt;</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    &lt;td&gt;&lt;code&gt;&amp;lt;configurable prefix&amp;gt;/&amp;lt;node address&amp;gt;/result/ota {&quot;result&quot;:&quot;&amp;lt;ota_result_text&amp;gt;,&quot;status&quot;:&quot;&amp;lt;ota_result_code&amp;gt;&quot;}&lt;/code&gt;&lt;/td&gt;</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;  &lt;/tr&gt;</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;  &lt;tr&gt;</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    &lt;td&gt;Identify node&lt;/td&gt;</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    &lt;td&gt;&lt;code&gt;&amp;lt;configurable prefix&amp;gt;/&amp;lt;node address&amp;gt;/set/identify&lt;/code&gt;&lt;/td&gt;</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    &lt;td&gt;None&lt;/td&gt;</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;  &lt;/tr&gt;</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;  &lt;tr&gt;</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;    &lt;td&gt;Reset node configuration&lt;/td&gt;</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;    &lt;td&gt;&lt;code&gt;&amp;lt;configurable prefix&amp;gt;/&amp;lt;node address&amp;gt;/set/reset&lt;/code&gt;&lt;/td&gt;</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    &lt;td&gt;&lt;code&gt;&amp;lt;configurable prefix&amp;gt;/&amp;lt;node address&amp;gt;/result/reset {}&lt;/code&gt;&lt;/td&gt;</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;  &lt;/tr&gt;</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;  &lt;tr&gt;</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    &lt;td&gt;Request measure RSSI&lt;/td&gt;</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;    &lt;td&gt;&lt;code&gt;&amp;lt;configurable prefix&amp;gt;/&amp;lt;node address&amp;gt;/get/rssi&lt;/code&gt;&lt;/td&gt;</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;    &lt;td&gt;&lt;code&gt;&amp;lt;configurable prefix&amp;gt;/&amp;lt;node address&amp;gt;/result/rssi {&quot;rssi&quot;:&amp;lt;RSSI&amp;gt;,&quot;channel&quot;:&amp;lt;WiFi channel&amp;gt;}&lt;/code&gt;&lt;/td&gt;</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;  &lt;/tr&gt;</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;&lt;/table&gt;</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;For instance, publishing `enigmaiot/12:34:56:78:90:12/get/version` will produce `enigmaiot/12:34:56:78:90:12/result/version 0.2.0`.</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;Messages are encoded to reduce the amount of bytes to be sent over internal protocol, so that the air time is as short as possible.</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;| Command | Msg type | Encoding |</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;| ------- | -------- | -------- |</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;| Get version | `0x01` | None |</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;| Version result | `0x81` | version as ASCII string |</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;| Get sleep time | `0x02` | None |</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;| Set sleep time | `0x03` | Sleep time in seconds (Unsigned integer - 32 bit) |</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;| Sleep time result | `0x82` | Sleep time in seconds (Unsigned integer - 32 bit) |</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;| OTA Update | `0xEF` | OTA update specific format |</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;| OTA Update result | `0xFF` | OTA result code (text and integer code) |</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;| Identify | `0x04` | None. Function to identify a physical node by flashing its LED |</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;| Reset node configuration | `0x05` | None. This will set node to factory config |</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;| Reset config confirmation | `0x85` | None |</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;| Request measure RSSI | `0x06` | None |</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;| Report measure RSSI | `0x86` | RSSI (signed integer - 8 bit), WiFi channel (unsigned integer - 8 bit) |</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;## OTA Update</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;OTA updates are transferred using the same mechanism. Firmware is sent over MQTT using a [Python script](./EnigmaIoTUpdate/EnigmaIoTUpdate.py). Then gateway selects the appropriate node and send this binary data over ESP-NOW.</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;As ESP-NOW restricts **maximum payload to 250 bytes per message** firmware is splitted in chunks. Every chunk is **212 bytes** long, so that it fits together with message headers and is multiple of 4. This splitting work is done by `EnigmaIoTUpdate.py` script.</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;### Using EnigmaIoTUpdate.py</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;A requirement is to have installed [Python3](https://www.python.org/download/releases/3.0/) in the computer used to do the update.</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;In order to run the update, you need to install [`paho-mqtt`](https://pypi.org/project/paho-mqtt/) library. To do that you can follow instructions [here](https://pypi.org/project/paho-mqtt/#installation).</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;```</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;$python3 ./EnigmaIoTUpdate.py --help</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;Usage: EnigmaIoTUpdate.py [options]</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;Options:</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;  -h, --help            show this help message and exit</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;  -f FILENAME, --file=FILENAME</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;                        File to program into device</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;  -d ADDRESS, --daddress=ADDRESS</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;                        Device address</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;  -t BASETOPIC, --topic=BASETOPIC</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;                        Base topic for MQTT messages</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;  -u MQTTUSER, --user=MQTTUSER</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;                        MQTT server username</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;  -P MQTTPASS, --password=MQTTPASS</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;                        MQTT server user password</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;  -S MQTTSERVER, --server=MQTTSERVER</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;                        MQTT server address or name</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;  -p MQTTPORT, --port=MQTTPORT</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;                        MQTT server port</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;  -s, --secure          Use secure TLS in MQTT connection. Normally you should</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;                          use port 8883</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;  -D, --speed          Sets formware delivery speed [fast | medium | slow]. The fastest</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;                          the biggest chance to get troubles during update. Fast option</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;                          normally works but medium is more resilient</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;  --unsecure            Use secure plain TCP in MQTT connection. Normally you</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;                          should use port 1883</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;```</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;An example of this command could be like this:</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;```</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;python3 ./EnigmaIoTUpdate.py \</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;             -f EnigmaIOTsensor.bin \</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;             -d 11:22:33:44:55:66 \</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;             -t enigmaiot \</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;             -u &quot;mymqttbrokeruser&quot; \</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;             -P &quot;mymqttbrokerpassword&quot; \</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;             -S mysecure.mqtt.server \</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;             -p 8883 \</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;             -D medium \</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;             -s</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;```</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;Notice that using ESP-NOW device address correspond to **MAC address** of your ESP8266.</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;It is very important to configure user and password on you MQTT broker. Besides, if it is going to be accessed from the Internet you should activate TLS encryption and a certificate.</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;## External libraries</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;- ESPAsyncWebServer -- https://github.com/me-no-dev/ESPAsyncWebServer</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;- ESPAsyncWiFiManager -- https://github.com/alanswx/ESPAsyncWiFiManager version &gt; 0.22</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;  </div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;- Arduino Crypto Library -- https://github.com/gmag11/CryptoArduino forked and formatted from https://github.com/rweather</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;- PubSubClient -- https://github.com/knolleary/pubsubclient</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;- CayenneLPP -- https://github.com/sabas1080/CayenneLPP version &gt; 1.0.2</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;- ArduinoJSON 6 -- https://github.com/bblanchon/ArduinoJson version &gt; 6.0.0</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;</div></div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
